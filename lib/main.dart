import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter_callkit_incoming/flutter_callkit_incoming.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:async';

import 'package:flutter_callkit_incoming/entities/entities.dart'; // Import Event enum
import 'screens/user_registration_screen.dart';
import 'screens/call_screen.dart';
import 'services/notification_service.dart';
import 'services/permissions_service.dart';


final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

// Tracks processed CallKit IDs to prevent duplicate UI/actions
Set<String> _processedCallKitIds = {};
Timer? _callAcceptanceTimer; // Debounces ACTION_CALL_ACCEPT events

/// Entry point
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();
  await PermissionsService.requestAllPermissions();

  FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);
  setupCallkitListeners();

  runApp(const MyApp());

  // Post-launch cold-start navigation from SharedPreferences
  WidgetsBinding.instance.addPostFrameCallback((_) async {
    final prefs = await SharedPreferences.getInstance();
    final pendingCallChannelId = prefs.getString('pendingCallChannelId');
    if (pendingCallChannelId != null) {
      print('DEBUG: App started with pending call. Navigating to CallScreen for channel: $pendingCallChannelId');
      await prefs.remove('pendingCallChannelId'); // Clear immediately
      _navigateToCallScreen(pendingCallChannelId);
    }
  });
}

void _navigateToCallScreen(String channelId) {
  if (navigatorKey.currentState != null && navigatorKey.currentState!.mounted) {
    bool alreadyOnCallScreen = false;
    navigatorKey.currentState?.popUntil((route) {
      if (route is MaterialPageRoute &&
          route.settings.name == '/callScreen' &&
          route.settings.arguments != null &&
          route.settings.arguments is Map &&
          (route.settings.arguments as Map)['channelId'] == channelId) {
        alreadyOnCallScreen = true;
      }
      return true; // Keep popping to ensure the check covers the stack
    });

    if (!alreadyOnCallScreen) {
      print('DEBUG: Pushing CallScreen for channel: $channelId');
      navigatorKey.currentState?.pushReplacement( // Use pushReplacement to avoid stacking
        MaterialPageRoute(
          builder: (_) => CallScreen(uid: 0, channelId: channelId),
          settings: RouteSettings(name: '/callScreen', arguments: {'channelId': channelId}),
        ),
      );
    } else {
      print('DEBUG: Already on CallScreen for channel $channelId. Not navigating again.');
    }
  } else {
    print('DEBUG: Navigator not ready to navigate to CallScreen.');
  }
}


/// Listen to CallKit events (Accept/Decline)
void setupCallkitListeners() {
  FlutterCallkitIncoming.onEvent.listen((event) async {
    final Event? eventType = event?.event;
    final body = event?.body;
    final callkitId = body?['id']; // This is the UUID generated by CallKit/plugin

    print('CallKit Event Received: ${eventType.toString()}, ID: $callkitId, Body: $body');
    print('DEBUG: eventType value (enum.toString()): "${eventType.toString()}"');
    print('DEBUG: eventType type: ${eventType.runtimeType}');


    if (callkitId == null) {
      print('DEBUG: CallKit event received with null ID. Skipping processing.');
      return;
    }

    switch (eventType) {
      case Event.actionCallIncoming:
        // Debounce subsequent ACTION_CALL_INCOMING events with the same ID
        if (_processedCallKitIds.contains(callkitId)) {
          print('DEBUG: Already processed ACTION_CALL_INCOMING for ID: $callkitId. Skipping.');
          return;
        }
        _processedCallKitIds.add(callkitId); // Mark as processed
        print('DEBUG: Processing new ACTION_CALL_INCOMING for ID: $callkitId.');
        // At this point, LocalNotificationService.showIncomingCallNotification has already been called
        // by the FirebaseMessaging.onMessage or firebaseMessagingBackgroundHandler listener.
        break;

      case Event.actionCallAccept:
        if (_callAcceptanceTimer != null && _callAcceptanceTimer!.isActive) {
          print('DEBUG: Call ACCEPT debounce active. Skipping duplicate accept event for ID: $callkitId');
          return;
        }

        _callAcceptanceTimer = Timer(const Duration(milliseconds: 500), () async {
          print('DEBUG: Call ACCEPT timer triggered for ID: $callkitId');
          final channelId = body?['extra']?['channelId'];
          if (channelId != null) {
            final prefs = await SharedPreferences.getInstance();
            await prefs.setString('pendingCallChannelId', channelId); // Store for cold-start resilience

            _navigateToCallScreen(channelId); // Trigger navigation to CallScreen
            await prefs.remove('pendingCallChannelId'); // Clear after navigation attempt
          } else {
            print('ERROR: ACTION_CALL_ACCEPT event missing channelId.');
          }
          _processedCallKitIds.remove(callkitId); // Clean up processed ID
          _callAcceptanceTimer = null; // Clear the timer
        });
        break;

      case Event.actionCallDecline:
      case Event.actionCallEnded:
      case Event.actionCallTimeout:
        final callId = body?['id'];
        if (callId != null) {
          print('CallKit ACTION_CALL_DECLINE/ENDED/TIMEOUT for ID: $callId');
          await FlutterCallkitIncoming.endCall(callId);
          final prefs = await SharedPreferences.getInstance();
          await prefs.remove('pendingCallChannelId'); // Clear any pending call
          _processedCallKitIds.remove(callId); // Clean up processed ID
          _callAcceptanceTimer?.cancel(); // Cancel any pending accept timers
          _callAcceptanceTimer = null;
        }
        break;

      default:
        print('DEBUG: Unhandled CallKit Event Type: ${eventType.toString()}');
        break;
    }
  });

  // This listener processes incoming FCM messages while the app is in the foreground.
  FirebaseMessaging.onMessage.listen((RemoteMessage message) {
    print('FCM Received (Foreground): ${message.data}');
    final callerId = message.data['callerId'];
    final channelId = message.data['channelId'];
    final fcmCallKitId = message.data['callkitId']; // Get CallKit ID from FCM

    // âœ… DEBOUNCE VISUAL NOTIFICATION: Only show CallKit UI if we haven't already processed this CallKit ID.
    // This handles scenarios where multiple FCMs for the *same* CallKit ID might arrive.
    if (fcmCallKitId != null && _processedCallKitIds.contains(fcmCallKitId)) {
        print('DEBUG: FCM for already processed CallKit ID: $fcmCallKitId. Skipping visual notification.');
        return;
    }

    if (callerId != null && channelId != null) {
      // Show the CallKit incoming UI, passing the consistent CallKit ID.
      LocalNotificationService.showIncomingCallNotification(callerId, channelId, incomingCallkitId: fcmCallKitId);
    }
  });
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Video Call App',
      navigatorKey: navigatorKey,
      theme: ThemeData.dark(),
      debugShowCheckedModeBanner: false,
      home: const UserRegistrationScreen(),
    );
  }
}